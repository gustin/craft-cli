#!/usr/bin/env bash
set -euo pipefail

# Craft CLI — thin wrapper around Craft's REST API
# Requires: CRAFT_API_KEY, CRAFT_API_BASE (set via mise)

if [[ -z "${CRAFT_API_KEY:-}" || -z "${CRAFT_API_BASE:-}" ]]; then
  echo "error: CRAFT_API_KEY and CRAFT_API_BASE must be set" >&2
  echo "hint: check .mise.local.toml" >&2
  exit 1
fi

FOLDER_CACHE="/tmp/craft-folders.json"
FOLDER_CACHE_TTL=300 # 5 minutes

# --- core helpers ---

_api() {
  local method="$1" path="$2"; shift 2
  curl -s -X "$method" \
    -H "Authorization: Bearer $CRAFT_API_KEY" \
    -H "Content-Type: application/json" \
    "$@" "${CRAFT_API_BASE}/${path}"
}

_api_md() {
  local path="$1"; shift
  curl -s -X GET \
    -H "Authorization: Bearer $CRAFT_API_KEY" \
    -H "Accept: text/markdown" \
    "$@" "${CRAFT_API_BASE}/${path}"
}

_api_upload() {
  local path="$1" content_type="$2"; shift 2
  curl -s -X POST \
    -H "Authorization: Bearer $CRAFT_API_KEY" \
    -H "Content-Type: $content_type" \
    --data-binary @- \
    "${CRAFT_API_BASE}/${path}"
}

_space_id() {
  _api GET connection | jq -r '.space.id'
}

_jq() { jq "$@"; }

_urlencode() {
  jq -rn --arg s "$1" '$s | @uri'
}

# --- folder resolution ---

_refresh_folder_cache() {
  if [[ -f "$FOLDER_CACHE" ]]; then
    local age=$(( $(date +%s) - $(stat -f%m "$FOLDER_CACHE" 2>/dev/null || echo 0) ))
    if (( age < FOLDER_CACHE_TTL )); then
      return
    fi
  fi
  _api GET folders > "$FOLDER_CACHE"
}

_resolve_folder() {
  local input="$1"
  # If it looks like a UUID, use as-is
  if [[ "$input" =~ ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$ ]]; then
    echo "$input"
    return
  fi
  _refresh_folder_cache
  # Search folder names: prefer exact match, then case-insensitive prefix, then substring
  local id
  id=$(jq -r --arg q "$input" '
    [.. | objects | select(.name?) | {id, name}]
    | (map(select(.name == $q)) | first | .id // null) //
      (map(select(.name | test("^\($q)"; "i"))) | first | .id // null) //
      (map(select(.name | test($q; "i"))) | first | .id // null)
    // empty
  ' "$FOLDER_CACHE")
  if [[ -z "$id" ]]; then
    echo "error: folder '$input' not found" >&2
    return 1
  fi
  echo "$id"
}

# --- mermaid helpers ---

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
RENDER_JS="$SCRIPT_DIR/../lib/render-mermaid.js"

_split_mmd() {
  local file="$1" tmpdir="$2"
  local name=""
  local outfile=""
  while IFS= read -r line; do
    if [[ "$line" =~ ^%%\ diagram:(.+)$ ]]; then
      name="${BASH_REMATCH[1]}"
      name="${name## }"
      name="${name%% }"
      outfile="$tmpdir/$name.mmd"
      > "$outfile"
    elif [[ -n "$outfile" ]]; then
      echo "$line" >> "$outfile"
    fi
  done < "$file"
}

_inject_ascii() {
  local md_file="$1" name="$2" ascii_file="$3"
  local marker="<!-- mermaid:$name -->"
  awk -v marker="$marker" -v file="$ascii_file" '
    BEGIN { skip = 0 }
    $0 == marker {
      print
      print "```"
      while ((getline line < file) > 0) print line
      close(file)
      print "```"
      skip = 1
      next
    }
    skip && /^<!-- mermaid:/ { skip = 0 }
    skip && /^#/ { skip = 0 }
    !skip { print }
  ' "$md_file" > "$md_file.tmp" && mv "$md_file.tmp" "$md_file"
}

# --- commands ---

cmd_folders() {
  local json_flag=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json|-j) json_flag=true; shift ;;
      *) shift ;;
    esac
  done

  local data
  data=$(_api GET folders)

  if $json_flag; then
    echo "$data" | _jq .
    return
  fi

  echo "$data" | jq -r '
    def print_tree(indent):
      .[] | "\(indent)\(.name) (\(.documentCount) docs) [\(.id)]",
      (.folders | if length > 0 then print_tree("\(indent)  ") else empty end);
    .items | print_tree("")
  '
}

cmd_docs() {
  local folder="" json_flag=false sort_flag="" since="" until="" limit=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --folder|-f) folder="$2"; shift 2 ;;
      --sort|-s) sort_flag="$2"; shift 2 ;;
      --since) since="$2"; shift 2 ;;
      --until) until="$2"; shift 2 ;;
      --limit|-n) limit="$2"; shift 2 ;;
      --json|-j) json_flag=true; shift ;;
      *) shift ;;
    esac
  done

  local params="fetchMetadata=true"
  if [[ -n "$folder" ]]; then
    local folder_id
    folder_id=$(_resolve_folder "$folder")
    params="${params}&folderId=$folder_id"
  fi
  if [[ -n "$since" ]]; then
    params="${params}&lastModifiedDateGte=$since"
  fi
  if [[ -n "$until" ]]; then
    params="${params}&lastModifiedDateLte=$until"
  fi

  local data
  data=$(_api GET "documents?$params")

  if $json_flag; then
    echo "$data" | _jq .
    return
  fi

  local limit_expr="."
  if [[ -n "$limit" ]]; then
    limit_expr=".[:$limit]"
  fi

  case "$sort_flag" in
    modified|updated|recent)
      echo "$data" | jq -r --argjson n "${limit:-0}" '.items | sort_by(.lastModifiedAt) | reverse | if $n > 0 then .[:$n] else . end | .[] | "\(.lastModifiedAt // "" | .[:10])  \(.id)  \(.title)"'
      ;;
    created)
      echo "$data" | jq -r --argjson n "${limit:-0}" '.items | sort_by(.createdAt) | reverse | if $n > 0 then .[:$n] else . end | .[] | "\(.createdAt // "" | .[:10])  \(.id)  \(.title)"'
      ;;
    *)
      echo "$data" | jq -r --argjson n "${limit:-0}" '.items | if $n > 0 then .[:$n] else . end | .[] | "\(.id)  \(.title)"'
      ;;
  esac
}

cmd_search() {
  local query="" folder="" json_flag=false since="" until=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --folder|-f) folder="$2"; shift 2 ;;
      --since) since="$2"; shift 2 ;;
      --until) until="$2"; shift 2 ;;
      --json|-j) json_flag=true; shift ;;
      -*) shift ;;
      *) query="$1"; shift ;;
    esac
  done

  if [[ -z "$query" ]]; then
    echo "usage: craft search \"query\" [--folder NAME] [--since DATE]" >&2
    return 1
  fi

  local params="include=$(_urlencode "$query")"
  if [[ -n "$folder" ]]; then
    local folder_id
    folder_id=$(_resolve_folder "$folder")
    params="${params}&folderIds=$folder_id"
  fi
  if [[ -n "$since" ]]; then
    params="${params}&lastModifiedDateGte=$since"
  fi
  if [[ -n "$until" ]]; then
    params="${params}&lastModifiedDateLte=$until"
  fi

  local data
  data=$(_api GET "documents/search?$params")

  if $json_flag; then
    echo "$data" | _jq .
    return
  fi

  echo "$data" | jq -r '.items[] | "\(.documentId)  \(.markdown // "" | gsub("\n"; " ") | .[:120])"'
}

cmd_read() {
  local doc_id="" json_flag=false meta_flag=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json|-j) json_flag=true; shift ;;
      --meta|-m) meta_flag=true; shift ;;
      -*) shift ;;
      *) doc_id="$1"; shift ;;
    esac
  done

  if [[ -z "$doc_id" ]]; then
    echo "usage: craft read <docId> [--meta]" >&2
    return 1
  fi

  if $json_flag; then
    _api GET "blocks?id=$doc_id&fetchMetadata=true" | _jq .
  elif $meta_flag; then
    local meta
    meta=$(_api GET "documents?fetchMetadata=true")
    echo "$meta" | jq -r --arg id "$doc_id" '.items[] | select(.id == $id) | "title: \(.title // .id)", "created: \(.createdAt // "unknown")", "modified: \(.lastModifiedAt // "unknown")", ""'
    _api_md "blocks?id=$doc_id"
  else
    _api_md "blocks?id=$doc_id"
  fi
}

cmd_today() {
  local json_flag=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json|-j) json_flag=true; shift ;;
      *) shift ;;
    esac
  done

  if $json_flag; then
    _api GET "blocks?date=today" | _jq .
  else
    _api_md "blocks?date=today"
  fi
}

cmd_create() {
  local title="" folder="" json_flag=false content=""
  # Read stdin first if available, before arg parsing touches it
  if [[ ! -t 0 ]]; then
    content=$(cat)
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --folder|-f) folder="$2"; shift 2 ;;
      --json|-j) json_flag=true; shift ;;
      -*) shift ;;
      *) title="$1"; shift ;;
    esac
  done

  if [[ -z "$title" ]]; then
    echo "usage: craft create \"title\" [--folder NAME] < content.md" >&2
    return 1
  fi

  # Build create payload
  local dest=""
  if [[ -n "$folder" ]]; then
    local folder_id
    folder_id=$(_resolve_folder "$folder")
    dest=", \"destination\": {\"folderId\": \"$folder_id\"}"
  fi

  local doc_result
  doc_result=$(_api POST documents -d "{\"documents\": [{\"title\": \"$title\"}]$dest}")
  local doc_id
  doc_id=$(echo "$doc_result" | jq -r '.items[0].id')

  if [[ -z "$doc_id" || "$doc_id" == "null" ]]; then
    echo "error: failed to create document" >&2
    echo "$doc_result" >&2
    return 1
  fi

  # If we captured stdin content, insert it
  if [[ -n "$content" ]]; then
    local payload
    payload=$(jq -n --arg md "$content" --arg id "$doc_id" \
      '{markdown: $md, position: {position: "end", pageId: $id}}')
    _api POST blocks -d "$payload" > /dev/null
  fi

  if $json_flag; then
    echo "$doc_result" | _jq .
  else
    echo "$doc_id  $title"
  fi
}

cmd_append() {
  local doc_id="" json_flag=false content=""
  if [[ ! -t 0 ]]; then
    content=$(cat)
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json|-j) json_flag=true; shift ;;
      -*) shift ;;
      *) doc_id="$1"; shift ;;
    esac
  done

  if [[ -z "$doc_id" ]]; then
    echo "usage: craft append <docId> < content.md" >&2
    return 1
  fi

  if [[ -z "$content" ]]; then
    echo "error: no content on stdin" >&2
    return 1
  fi

  local payload
  payload=$(jq -n --arg md "$content" --arg id "$doc_id" \
    '{markdown: $md, position: {position: "end", pageId: $id}}')

  local result
  result=$(_api POST blocks -d "$payload")

  if $json_flag; then
    echo "$result" | _jq .
  else
    echo "ok"
  fi
}

cmd_update() {
  local block_id="" json_flag=false content=""
  if [[ ! -t 0 ]]; then
    content=$(cat)
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json|-j) json_flag=true; shift ;;
      -*) shift ;;
      *) block_id="$1"; shift ;;
    esac
  done

  if [[ -z "$block_id" ]]; then
    echo "usage: craft update <blockId> < content.md" >&2
    return 1
  fi

  if [[ -z "$content" ]]; then
    echo "error: no content on stdin" >&2
    return 1
  fi

  local payload
  payload=$(jq -n --arg md "$content" --arg id "$block_id" \
    '{blocks: [{id: $id, markdown: $md}]}')

  local result
  result=$(_api PUT blocks -d "$payload")

  if $json_flag; then
    echo "$result" | _jq .
  else
    echo "ok"
  fi
}

cmd_delete() {
  local doc_id=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -*) shift ;;
      *) doc_id="$1"; shift ;;
    esac
  done

  if [[ -z "$doc_id" ]]; then
    echo "usage: craft delete <docId>" >&2
    return 1
  fi

  _api DELETE documents -d "{\"documentIds\": [\"$doc_id\"]}" | jq -r '.items[]' 2>/dev/null
  echo "ok (moved to trash)"
}

cmd_mv() {
  local doc_id="" dest="" json_flag=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json|-j) json_flag=true; shift ;;
      -*) shift ;;
      *)
        if [[ -z "$doc_id" ]]; then
          doc_id="$1"
        else
          dest="$1"
        fi
        shift ;;
    esac
  done

  if [[ -z "$doc_id" || -z "$dest" ]]; then
    echo "usage: craft mv <docId> <FOLDER|unsorted>" >&2
    return 1
  fi

  local dest_json
  if [[ "$dest" == "unsorted" ]]; then
    dest_json="{\"destination\": \"unsorted\"}"
  else
    local folder_id
    folder_id=$(_resolve_folder "$dest")
    dest_json="{\"destination\": {\"folderId\": \"$folder_id\"}}"
  fi

  local result
  result=$(_api PUT documents/move -d "{\"documentIds\": [\"$doc_id\"], $dest_json}")

  if $json_flag; then
    echo "$result" | _jq .
  else
    echo "ok"
  fi
}

cmd_recent() {
  local limit="10" folder="" json_flag=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --folder|-f) folder="$2"; shift 2 ;;
      --limit|-n) limit="$2"; shift 2 ;;
      --json|-j) json_flag=true; shift ;;
      *) shift ;;
    esac
  done

  local args=(--sort modified --limit "$limit")
  if [[ -n "$folder" ]]; then
    args+=(--folder "$folder")
  fi
  if $json_flag; then
    args+=(--json)
  fi
  cmd_docs "${args[@]}"
}

cmd_upload() {
  local doc_id="" position="end" content=""
  if [[ ! -t 0 ]]; then
    content=$(cat)
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --position|-p) position="$2"; shift 2 ;;
      -*) shift ;;
      *) doc_id="$1"; shift ;;
    esac
  done

  if [[ -z "$doc_id" ]]; then
    echo "usage: craft upload <docId> < file.svg" >&2
    return 1
  fi

  if [[ -z "$content" ]]; then
    echo "error: no content on stdin" >&2
    return 1
  fi

  local result
  result=$(echo "$content" | _api_upload "upload?position=$position&pageId=$doc_id" "application/octet-stream")
  echo "$result" | jq -r '"uploaded: \(.blockId)  \(.assetUrl // "")"'
}

cmd_link() {
  local doc_id=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -*) shift ;;
      *) doc_id="$1"; shift ;;
    esac
  done

  if [[ -z "$doc_id" ]]; then
    echo "usage: craft link <docId>" >&2
    return 1
  fi

  local space_id
  space_id=$(_space_id)
  echo "craftdocs://open?spaceId=$space_id&blockId=$doc_id"
}

cmd_open() {
  local doc_id=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -*) shift ;;
      *) doc_id="$1"; shift ;;
    esac
  done

  if [[ -z "$doc_id" ]]; then
    echo "usage: craft open <docId>" >&2
    return 1
  fi

  local space_id
  space_id=$(_space_id)
  open "craftdocs://open?spaceId=$space_id&blockId=$doc_id"
}

cmd_mkdir() {
  local name="" parent="" json_flag=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --parent|-p) parent="$2"; shift 2 ;;
      --json|-j) json_flag=true; shift ;;
      -*) shift ;;
      *) name="$1"; shift ;;
    esac
  done

  if [[ -z "$name" ]]; then
    echo "usage: craft mkdir \"name\" [--parent FOLDER]" >&2
    return 1
  fi

  local dest=""
  if [[ -n "$parent" ]]; then
    local parent_id
    parent_id=$(_resolve_folder "$parent")
    dest=", \"destination\": {\"parentFolderId\": \"$parent_id\"}"
  fi

  local result
  result=$(_api POST folders -d "{\"folders\": [{\"name\": \"$name\"}]$dest}")
  # Invalidate folder cache
  rm -f "$FOLDER_CACHE"

  if $json_flag; then
    echo "$result" | _jq .
  else
    echo "$result" | jq -r '.items[0] | "\(.id)  \(.name)"'
  fi
}

cmd_mvfolder() {
  local folder="" dest="" json_flag=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json|-j) json_flag=true; shift ;;
      -*) shift ;;
      *)
        if [[ -z "$folder" ]]; then
          folder="$1"
        else
          dest="$1"
        fi
        shift ;;
    esac
  done

  if [[ -z "$folder" || -z "$dest" ]]; then
    echo "usage: craft mvfolder <FOLDER> <DEST_FOLDER|root>" >&2
    return 1
  fi

  local folder_id
  folder_id=$(_resolve_folder "$folder")

  local dest_json
  if [[ "$dest" == "root" ]]; then
    dest_json="{\"destination\": \"root\"}"
  else
    local dest_id
    dest_id=$(_resolve_folder "$dest")
    dest_json="{\"destination\": {\"parentFolderId\": \"$dest_id\"}}"
  fi

  local result
  result=$(_api PUT folders/move -d "{\"folderIds\": [\"$folder_id\"], $dest_json}")
  rm -f "$FOLDER_CACHE"

  if $json_flag; then
    echo "$result" | _jq .
  else
    echo "ok"
  fi
}

cmd_rmfolder() {
  local folder=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -*) shift ;;
      *) folder="$1"; shift ;;
    esac
  done

  if [[ -z "$folder" ]]; then
    echo "usage: craft rmfolder <FOLDER>" >&2
    return 1
  fi

  local folder_id
  folder_id=$(_resolve_folder "$folder")

  _api DELETE folders -d "{\"folderIds\": [\"$folder_id\"]}" | jq -r '.items[]' 2>/dev/null
  rm -f "$FOLDER_CACHE"
  echo "ok (docs moved to parent)"
}

# --- block-level commands ---

cmd_grep() {
  local doc_id="" pattern="" json_flag=false context=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json|-j) json_flag=true; shift ;;
      -C) context="$2"; shift 2 ;;
      -*) shift ;;
      *)
        if [[ -z "$pattern" ]]; then
          pattern="$1"
        else
          doc_id="$1"
        fi
        shift ;;
    esac
  done

  if [[ -z "$pattern" || -z "$doc_id" ]]; then
    echo "usage: craft grep \"pattern\" <docId> [-C N]" >&2
    return 1
  fi

  local params="blockId=$doc_id&pattern=$(_urlencode "$pattern")"
  if [[ -n "$context" ]]; then
    params="${params}&beforeBlockCount=$context&afterBlockCount=$context"
  fi

  local data
  data=$(_api GET "blocks/search?$params")

  if $json_flag; then
    echo "$data" | _jq .
    return
  fi

  echo "$data" | jq -r '.items[] |
    (if .beforeBlocks then .beforeBlocks[] | "  \(.markdown // "")" else empty end),
    "> \(.markdown // "")",
    (if .afterBlocks then .afterBlocks[] | "  \(.markdown // "")" else empty end),
    "---"'
}

cmd_rmblock() {
  local block_ids=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -*) shift ;;
      *) block_ids+=("$1"); shift ;;
    esac
  done

  if [[ ${#block_ids[@]} -eq 0 ]]; then
    echo "usage: craft rmblock <blockId> [blockId...]" >&2
    return 1
  fi

  local ids_json
  ids_json=$(printf '%s\n' "${block_ids[@]}" | jq -R . | jq -s .)

  local result
  result=$(_api DELETE blocks -d "{\"blockIds\": $ids_json}")
  echo "$result" | jq -r '.items[].id' 2>/dev/null
  echo "ok"
}

cmd_mvblock() {
  local block_ids=() dest_doc="" position="end"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --to) dest_doc="$2"; shift 2 ;;
      --position|-p) position="$2"; shift 2 ;;
      -*) shift ;;
      *) block_ids+=("$1"); shift ;;
    esac
  done

  if [[ ${#block_ids[@]} -eq 0 || -z "$dest_doc" ]]; then
    echo "usage: craft mvblock <blockId>... --to <docId>" >&2
    return 1
  fi

  local ids_json
  ids_json=$(printf '%s\n' "${block_ids[@]}" | jq -R . | jq -s .)

  local result
  result=$(_api PUT blocks/move -d "$(jq -n --argjson ids "$ids_json" --arg doc "$dest_doc" --arg pos "$position" \
    '{blockIds: $ids, position: {position: $pos, pageId: $doc}}')")
  echo "$result" | jq -r '.items[].id' 2>/dev/null
  echo "ok"
}

# --- collection commands ---

cmd_collections() {
  local doc_id="" json_flag=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --doc|-d) doc_id="$2"; shift 2 ;;
      --json|-j) json_flag=true; shift ;;
      *) shift ;;
    esac
  done

  local params=""
  if [[ -n "$doc_id" ]]; then
    params="?documentIds=$doc_id"
  fi

  local data
  data=$(_api GET "collections$params")

  if $json_flag; then
    echo "$data" | _jq .
    return
  fi

  echo "$data" | jq -r '.items[] | "\(.id)  \(.name) (\(.itemCount) items)  doc:\(.documentId)"'
}

cmd_collection_schema() {
  local col_id="" json_flag=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json|-j) json_flag=true; shift ;;
      -*) shift ;;
      *) col_id="$1"; shift ;;
    esac
  done

  if [[ -z "$col_id" ]]; then
    echo "usage: craft collection:schema <collectionId>" >&2
    return 1
  fi

  local data
  data=$(_api GET "collections/$col_id/schema?format=schema")

  if $json_flag; then
    echo "$data" | _jq .
    return
  fi

  echo "$data" | jq -r '
    "Collection: \(.name)",
    "Content field: \(.contentPropDetails.name)",
    "",
    "Properties:",
    (.properties[] | "  \(.name) (\(.type))\(if .options then " = " + (.options | join(", ")) else "" end)")
  '
}

cmd_collection_items() {
  local col_id="" json_flag=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json|-j) json_flag=true; shift ;;
      -*) shift ;;
      *) col_id="$1"; shift ;;
    esac
  done

  if [[ -z "$col_id" ]]; then
    echo "usage: craft collection:items <collectionId>" >&2
    return 1
  fi

  local data
  data=$(_api GET "collections/$col_id/items?maxDepth=0")

  if $json_flag; then
    echo "$data" | _jq .
    return
  fi

  echo "$data" | jq -r '.items[] | "\(.id)  \(.title)  \(.properties // {} | to_entries | map("\(.key)=\(.value)") | join("  "))"'
}

cmd_collection_add() {
  local col_id="" title="" json_flag=false props=""
  if [[ ! -t 0 ]]; then
    props=$(cat)
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json|-j) json_flag=true; shift ;;
      -*) shift ;;
      *)
        if [[ -z "$col_id" ]]; then
          col_id="$1"
        else
          title="$1"
        fi
        shift ;;
    esac
  done

  if [[ -z "$col_id" || -z "$title" ]]; then
    echo "usage: craft collection:add <collectionId> \"title\" [< props.json]" >&2
    return 1
  fi

  local payload
  if [[ -n "$props" ]]; then
    payload=$(jq -n --arg t "$title" --argjson p "$props" '{items: [{title: $t, properties: $p}]}')
  else
    payload=$(jq -n --arg t "$title" '{items: [{title: $t}]}')
  fi

  local result
  result=$(_api POST "collections/$col_id/items" -d "$payload")

  if $json_flag; then
    echo "$result" | _jq .
  else
    echo "$result" | jq -r '.items[0] | "\(.id)  \(.title)"'
  fi
}

cmd_collection_update() {
  local col_id="" item_id="" json_flag=false props=""
  if [[ ! -t 0 ]]; then
    props=$(cat)
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json|-j) json_flag=true; shift ;;
      -*) shift ;;
      *)
        if [[ -z "$col_id" ]]; then
          col_id="$1"
        elif [[ -z "$item_id" ]]; then
          item_id="$1"
        fi
        shift ;;
    esac
  done

  if [[ -z "$col_id" || -z "$item_id" || -z "$props" ]]; then
    echo "usage: craft collection:update <collectionId> <itemId> < props.json" >&2
    return 1
  fi

  local payload
  payload=$(jq -n --arg id "$item_id" --argjson p "$props" '{itemsToUpdate: [{id: $id, properties: $p}]}')

  local result
  result=$(_api PUT "collections/$col_id/items" -d "$payload")

  if $json_flag; then
    echo "$result" | _jq .
  else
    echo "ok"
  fi
}

cmd_collection_rm() {
  local col_id="" item_ids=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -*) shift ;;
      *)
        if [[ -z "$col_id" ]]; then
          col_id="$1"
        else
          item_ids+=("$1")
        fi
        shift ;;
    esac
  done

  if [[ -z "$col_id" || ${#item_ids[@]} -eq 0 ]]; then
    echo "usage: craft collection:rm <collectionId> <itemId> [itemId...]" >&2
    return 1
  fi

  local ids_json
  ids_json=$(printf '%s\n' "${item_ids[@]}" | jq -R . | jq -s .)

  _api DELETE "collections/$col_id/items" -d "{\"idsToDelete\": $ids_json}" | jq -r '.items[]' 2>/dev/null
  echo "ok"
}

# --- tasks and other ---

cmd_tasks() {
  local scope="active" json_flag=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --scope|-s) scope="$2"; shift 2 ;;
      --json|-j) json_flag=true; shift ;;
      *) shift ;;
    esac
  done

  local data
  data=$(_api GET "tasks?scope=$scope")

  if $json_flag; then
    echo "$data" | _jq .
    return
  fi

  echo "$data" | jq -r '.items[] | "\(.id)  [\(.taskInfo.state // "todo")]  \(.markdown // "")"'
}

cmd_render() {
  local mmd_file="" doc_id="" local_only=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --doc|-d) doc_id="$2"; shift 2 ;;
      --local-only|-l) local_only=true; shift ;;
      -*) shift ;;
      *) mmd_file="$1"; shift ;;
    esac
  done

  if [[ -z "$mmd_file" ]]; then
    echo "usage: craft render <file.mmd> [--doc DOC_ID] [--local-only]" >&2
    return 1
  fi

  if [[ ! -f "$mmd_file" ]]; then
    echo "error: file not found: $mmd_file" >&2
    return 1
  fi

  if ! $local_only && [[ -z "$doc_id" ]]; then
    echo "error: --doc required unless --local-only" >&2
    return 1
  fi

  local md_file="${mmd_file%.mmd}.md"
  if [[ ! -f "$md_file" ]]; then
    echo "error: markdown file not found: $md_file" >&2
    return 1
  fi

  local tmpdir
  tmpdir=$(mktemp -d)
  trap "rm -rf $tmpdir" EXIT

  _split_mmd "$mmd_file" "$tmpdir"

  local count=0
  for diagram in "$tmpdir"/*.mmd; do
    [[ -f "$diagram" ]] || continue
    local name
    name=$(basename "$diagram" .mmd)

    # Render ASCII and inject into markdown
    local ascii_file="$tmpdir/$name.txt"
    node "$RENDER_JS" ascii < "$diagram" > "$ascii_file"
    _inject_ascii "$md_file" "$name" "$ascii_file"
    echo "ascii: $name"

    # Upload SVG to Craft doc
    if ! $local_only; then
      local svg
      svg=$(node "$RENDER_JS" svg < "$diagram")

      # Search for mermaid marker block in doc
      local search_result
      search_result=$(_api GET "blocks/search?blockId=$doc_id&pattern=$(_urlencode "mermaid:$name")&afterBlockCount=1")

      local marker_block_id
      marker_block_id=$(echo "$search_result" | jq -r '.items[0].id // empty')

      if [[ -z "$marker_block_id" ]]; then
        echo "warn: marker 'mermaid:$name' not found in doc, skipping SVG upload" >&2
        continue
      fi

      # Check if the block after marker is an image, delete it if so
      local after_type
      after_type=$(echo "$search_result" | jq -r '.items[0].afterBlocks[0].type // empty')
      if [[ "$after_type" == "image" ]]; then
        local after_id
        after_id=$(echo "$search_result" | jq -r '.items[0].afterBlocks[0].id')
        _api DELETE blocks -d "{\"blockIds\": [\"$after_id\"]}" > /dev/null
      fi

      # Upload SVG after marker block
      echo "$svg" | _api_upload "upload?position=after&siblingId=$marker_block_id" "image/svg+xml" > /dev/null
      echo "svg:   $name"
    fi

    count=$((count + 1))
  done

  echo "rendered $count diagram(s)"
}

cmd_help() {
  cat <<'EOF'
craft — Craft.do workspace CLI

Read:
  craft folders                           List folder tree
  craft recent [--limit N] [--folder F]   Recently modified docs (default 10)
  craft docs [--folder NAME|ID]           List documents
        [--sort modified|created]           Sort by date (newest first)
        [--since DATE] [--until DATE]       Filter by modified date
        [--limit N]                         Limit results
  craft search "query" [--folder NAME]    Search across all docs
        [--since DATE] [--until DATE]       Filter by modified date
  craft read <docId> [--meta]             Read doc as markdown (--meta for timestamps)
  craft grep "pattern" <docId> [-C N]     Search blocks within a doc
  craft today                             Read today's daily note
  craft tasks [--scope active|inbox]      List tasks

Write:
  craft create "title" [--folder NAME]    Create doc (stdin for content)
  craft append <docId>                    Append to doc (stdin)
  craft update <blockId>                  Update block (stdin)
  craft upload <docId>                    Upload file/image (stdin)
  craft mv <docId> <FOLDER|unsorted>      Move doc to folder
  craft delete <docId>                    Move doc to trash

Blocks:
  craft rmblock <blockId> [blockId...]    Delete blocks
  craft mvblock <blockId>... --to <docId> Move blocks to another doc

Folders:
  craft mkdir "name" [--parent FOLDER]    Create folder
  craft mvfolder <FOLDER> <DEST|root>     Move folder
  craft rmfolder <FOLDER>                 Delete folder (docs go to parent)

Collections:
  craft collections [--doc DOC_ID]        List collections
  craft collection:schema <collectionId>  Show collection schema
  craft collection:items <collectionId>   List collection items
  craft collection:add <colId> "title"    Add item (stdin for props JSON)
  craft collection:update <colId> <itemId>  Update item (stdin for props JSON)
  craft collection:rm <colId> <itemId>... Remove items

Render:
  craft render <file.mmd> [--doc DOC_ID]  Render mermaid to ASCII + SVG
        [--local-only]                      Skip Craft upload, ASCII only

Other:
  craft open <docId>                      Open in Craft app
  craft link <docId>                      Print deep link URL

Flags:
  --json, -j                              Raw JSON output
  --folder, -f NAME|ID                    Filter by folder

Dates: ISO (2026-01-28) or relative (today, yesterday, tomorrow)
EOF
}

# --- dispatch ---

cmd="${1:-help}"; shift || true

case "$cmd" in
  folders)  cmd_folders "$@" ;;
  recent)   cmd_recent "$@" ;;
  docs)     cmd_docs "$@" ;;
  search)   cmd_search "$@" ;;
  read)     cmd_read "$@" ;;
  grep)     cmd_grep "$@" ;;
  today)    cmd_today "$@" ;;
  create)   cmd_create "$@" ;;
  append)   cmd_append "$@" ;;
  update)   cmd_update "$@" ;;
  upload)   cmd_upload "$@" ;;
  mv)       cmd_mv "$@" ;;
  delete)   cmd_delete "$@" ;;
  rmblock)  cmd_rmblock "$@" ;;
  mvblock)  cmd_mvblock "$@" ;;
  mkdir)    cmd_mkdir "$@" ;;
  mvfolder) cmd_mvfolder "$@" ;;
  rmfolder) cmd_rmfolder "$@" ;;
  collections)        cmd_collections "$@" ;;
  collection:schema)  cmd_collection_schema "$@" ;;
  collection:items)   cmd_collection_items "$@" ;;
  collection:add)     cmd_collection_add "$@" ;;
  collection:update)  cmd_collection_update "$@" ;;
  collection:rm)      cmd_collection_rm "$@" ;;
  render)   cmd_render "$@" ;;
  open)     cmd_open "$@" ;;
  link)     cmd_link "$@" ;;
  tasks)    cmd_tasks "$@" ;;
  help|--help|-h) cmd_help ;;
  *)
    echo "error: unknown command '$cmd'" >&2
    echo "run 'craft help' for usage" >&2
    exit 1
    ;;
esac
